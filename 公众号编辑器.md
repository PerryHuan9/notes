# 微信编辑器

## 项目背景
我们实现的图文编辑器主要是为微信公众号文章服务的，用户可以在我们的编辑器上完成整个文章的编写，包括使用模板，应用主题，添加素材等等。所以我们的编辑器要求实现基础的文档编辑功能，还需要有承载样式的能力，即能够渲染出丰富的素材样式。还需要打通整个素材生产链路，设计师提供了一份PSD文件，PSD文件可能包含标题，图片，卡片等素材。我们需要解析PSD文件，并提取转换出我们编辑器支持的模板、主题或素材。

## 文档编辑器
第一步是需要实现一个类似notion的文档编辑器。我们是基于`prosemirror`搭建了整个文档编辑器，总的过程是使用`prosemirror`定义各种块，如标题，段落等，然后为不同的块增加不同交互。那么prosemirror又是怎样构建编辑器呢？`prosemirror`还是基于浏览器`contenteditable`的接口做上层封装，主要有三部分，`state`，`view`和`transaction`。
### `state`文档状态
`state`是文档的状态，主要包含文档树`doc`对象和光标`selection`, 它是一个`immutable`的对象，当文档内容变更，或者光标位置改变时，会基于旧的state生成一个新的state，这样有一个好处，可以轻易实现回退和前进功能，只需要使用数组收集整个编辑过程的`state`，就能通过应用不同的state来做到回退和前进的功能。`state`下的文档树对象是一个类似于`react` `virtual dom`的东西，只不过它采用时自己的格式，与主流`virtual dom`数据格式不一致。有了这一个中间层，就允许将文档对象渲染成`markdown`或其它文档。文档树下有不同类型的节点，也就是块，这些块是我们通过`schema`定义，在定义一个块时，需要声明它允许包含内容，比如只允许包含文字，还有通过`toDOM`方法定义它转换`html`结构。

### `view`视图
prosemirror `view` 负责将`state`在浏览器上渲染出来和响应用户的交互，`view`和`state`是双向绑定的，当用户改变编辑器的内容时，view会将修改同步到state上，当state改变时，view也会跟随更新。

### `transaction`变更state
上面讲到`view`改变时也会变更state， 那么state是如何更新的，在ProseMirror中，所有的修改都是通过`transaction`，当我们通过代码修改光标位置，实际上是`dispatch`一个修改光标的`transaction`,旧的`state`通过应用这个`transaction`得到一个新的`state`， 用户修改编辑器内容时， view也是根据事件生成一个transaction，然后应用到`state`上.`transaction`下还有用来描述修改的原子性操作`step`，也就是步骤，所有的修改都会转换成对应类型的`step`， 这也为协同提供了更好的支持，


## 承载样式 `&` 打通生产链路

### 渲染层实现
前面说了，定义块的时候需要提供一个`toDom`方法，来将块转成对应的`html`结构，我们可以将块转成任意`html`结构，然后装饰可以通过绝对定位来实现，边框背景可以通过`border-image`来实现。但遗憾的是，微信公众号不支持绝对定位，也不支持边框背景。我们只能通过另外的手段来实现这些功能，我们通过九宫格来实现了边框背景，通过了`margin`负值以及`transform`的手段实现装饰元素的偏移，总的来说就是实现了渲染层，引入`box-style`的概念，有普通背景类型的`box-style`,有装饰类型的`boy-style`， 智能拉伸类型`boy-style`，还有反向拉伸的`box-style`。将数据传给渲染层，就可以渲染出设计稿对应的素材。


### 生产工具
前文说到我们实现了渲染层，用来还原素材，但我们不可能人工还原设计师提供设计稿，这样效率是极其低下的，那么应该怎么将设计师提供的`PSD`转化成我们渲染层支持的数据结构？早期我们的想法是通过对`psd`打标签，在不同图层，不同目录通过名字来表明它是什么类似的渲染层元素，即是装饰元素还是背景，这样在转换的时候就可以根据这些标签来转化成我们对应的素材。但这种打标签的方式对设计师实在是太不友好了，所以后面我们决定提供一个生产工具，在生产编辑器中，设计师先上传`psd`，我们将`psd`解析成平面元素，然后再让设计师决定将这些元素转化成什么样的素材。


### 组合素材
除了基础的块，如标题，图片，重点文本之类，我们还提供了组合块，允许将多个基础块组合到一起，如主副标题，图片卡片，文字卡片等等。早期我们采用了一套有限制的方案，即某个确定的组合块只能放固定的基础块，并且它的顺序也是定义好的。但是后面觉得这套方案对用户不太友好，比如用户想在我们组合块里面增加其它的内容，结果它发现加不进来。所以后面改用一套没有限制的方案，我们实现了一个flexbox块作为容器，使用这个容器组织基础块，就实现了不同的组合块。组合块加上了样式就能实现组合素材。组合块还有另外一个目的，当用户选中多个块时，我们可以从素材库匹配筛选出允许转换的组合素材，这样用户的写作效率能得到进一步提高。


